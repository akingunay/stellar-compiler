/*
 * generated by Xtext 2.14.0
 */
package uk.ac.lancaster.scc.turtles.stellar.lang.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.lancaster.scc.turtles.stellar.lang.bSPL.Protocol
import uk.ac.lancaster.scc.turtles.stellar.lang.bSPL.Parameters
import uk.ac.lancaster.scc.turtles.stellar.lang.bSPL.MessageReference
import uk.ac.lancaster.scc.turtles.stellar.lang.bSPL.Role
import uk.ac.lancaster.scc.turtles.stellar.lang.bSPL.Parameter
import java.util.Set

class BSPLGenerator extends AbstractGenerator {

	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val protocolName = resource.allContents.toIterable.filter(Protocol).head.name
		val generatedPackagePath = "uk/ac/lancaster/scc/turtles/stellar/generated" + "/" + protocolName.toFirstLower;
		val generatedPackage = "uk.ac.lancaster.scc.turtles.stellar.generated" + "." + protocolName.toFirstLower;
		val libraryPackage = "uk.ac.lancaster.scc.turtles.stellar.core";
		
		val protocolSchemaCompiler = new ProtocolSchemaCompiler(protocolName, generatedPackage, libraryPackage)
		fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstUpper + "Schema.java", protocolSchemaCompiler.compile(resource));
		
		val messageNameEnumCompiler = new MessageNameEnumCompiler(protocolName, generatedPackage)
		fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstUpper + "MessageName.java", messageNameEnumCompiler.compile(resource));
		val parameterNameEnumCompiler = new ParameterNameEnumCompiler(protocolName, generatedPackage)
		fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstUpper + "ParameterName.java", parameterNameEnumCompiler.compile(resource));
		val roleNameEnumCompiler = new RoleNameEnumCompiler(protocolName, generatedPackage)
		fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstUpper + "RoleName.java", roleNameEnumCompiler.compile(resource));
		
		
		val protocolKeys = resource.allContents.toIterable.filter(Parameters).head.parameters.filter[p | p.isKey].map[p | p.name].toSet
		val initMessages = resource.getInitMessages
		val messageCompiler = new MessageCompiler(generatedPackage, libraryPackage)
		val enabledMessageCompiler = new EnabledMessageCompiler(protocolName, generatedPackage, libraryPackage)
		val messageSchemaCompiler = new MessageSchemaCompiler(protocolName, generatedPackage, libraryPackage, protocolKeys)
		for (reference : resource.allContents.toIterable.filter(MessageReference)) {
			fsa.generateFile(generatedPackagePath + "/" + reference.name.toFirstUpper + ".java", messageCompiler.compile(reference));
			fsa.generateFile(generatedPackagePath + "/" + reference.name.toFirstUpper + "Schema.java", messageSchemaCompiler.compile(reference));
			if (initMessages.contains(reference)) {
				fsa.generateFile(generatedPackagePath + "/" + "Enabled" + reference.name.toFirstUpper + ".java", enabledMessageCompiler.compileInit(reference));
			} else {
				fsa.generateFile(generatedPackagePath + "/" + "Enabled" + reference.name.toFirstUpper + ".java", enabledMessageCompiler.compileNonInit(reference));
			}
		}
		
		val nonInitMessages = resource.allContents.toIterable.filter(MessageReference).filter[r | !initMessages.contains(r)].map[r | r].toList
		val messageHandlerCompiler = new MessageHandlerCompiler(generatedPackage)
		val agentCompiler = new AgentCompiler(protocolName, generatedPackage, libraryPackage)
		val mySQLCompiler = new MySQLSchemaCompiler(protocolName, protocolKeys)
		for (role : resource.allContents.toIterable.filter(Role)) {
			fsa.generateFile(generatedPackagePath + "/" + role.name.toFirstUpper + "MessageHandler.java", messageHandlerCompiler.compile(resource, role));
			fsa.generateFile(generatedPackagePath + "/" + role.name.toFirstUpper + "Agent.java", agentCompiler.compile(resource, role, initMessages, nonInitMessages));
			fsa.generateFile(role.name + ".sql", mySQLCompiler.compile(resource, role));
		}
		
	}
	
	private def getInitMessages(Resource resource) {
		val publicInParameters = resource.allContents.toIterable.filter(Parameter).filter[p | p.adornment.equals("in")].map(p | p.name).toSet
		resource.allContents.toIterable.filter(MessageReference).filter[r | isInitMessage(r, publicInParameters)].toList
	}
	
	// FIXME nil is not considered
	private def isInitMessage(MessageReference reference, Set<String> publicInParameters) {
		for (parameter : reference.parameters.referenceParameters) {
			if (!parameter.adornment.equals("out") && ((parameter.adornment.equals("in") && !publicInParameters.contains(parameter.name)))) {
				return false
			}
		}
		true
	}
}
